# Generated from grammar.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,21,330,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,1,0,3,0,122,8,0,1,0,1,0,1,0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,3,2,
        134,8,2,1,3,1,3,1,3,1,3,1,4,3,4,141,8,4,1,5,1,5,1,5,1,5,1,5,1,6,
        1,6,1,6,1,7,1,7,3,7,153,8,7,1,8,1,8,1,8,1,9,3,9,159,8,9,1,10,3,10,
        162,8,10,1,11,3,11,165,8,11,1,12,3,12,168,8,12,1,13,3,13,171,8,13,
        1,14,3,14,174,8,14,1,15,3,15,177,8,15,1,16,3,16,180,8,16,1,17,1,
        17,1,17,1,18,1,18,1,18,1,19,1,19,3,19,190,8,19,1,20,1,20,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,1,21,3,21,202,8,21,1,22,1,22,1,22,1,
        22,1,22,1,23,3,23,210,8,23,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,
        26,1,26,1,26,1,26,1,26,1,26,1,26,1,27,1,27,1,27,1,27,1,28,1,28,3,
        28,232,8,28,1,29,1,29,1,29,1,30,1,30,1,30,1,31,3,31,241,8,31,1,32,
        1,32,1,32,1,33,1,33,3,33,248,8,33,1,34,3,34,251,8,34,1,35,1,35,1,
        35,1,36,1,36,1,37,3,37,259,8,37,1,38,1,38,3,38,263,8,38,1,39,1,39,
        1,40,3,40,268,8,40,1,41,1,41,1,42,1,42,1,43,1,43,3,43,276,8,43,1,
        44,1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,286,8,46,1,47,4,47,289,
        8,47,11,47,12,47,290,1,48,1,48,3,48,295,8,48,1,49,1,49,3,49,299,
        8,49,1,50,1,50,1,50,1,50,1,51,1,51,1,52,1,52,1,52,1,53,1,53,1,53,
        1,54,1,54,1,54,1,55,1,55,1,55,1,56,1,56,1,56,1,57,3,57,323,8,57,
        1,58,3,58,326,8,58,1,59,1,59,1,59,0,0,60,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,0,4,1,0,2,3,2,0,7,7,11,11,2,0,5,5,20,
        20,1,0,5,6,300,0,121,1,0,0,0,2,126,1,0,0,0,4,133,1,0,0,0,6,135,1,
        0,0,0,8,140,1,0,0,0,10,142,1,0,0,0,12,147,1,0,0,0,14,152,1,0,0,0,
        16,154,1,0,0,0,18,158,1,0,0,0,20,161,1,0,0,0,22,164,1,0,0,0,24,167,
        1,0,0,0,26,170,1,0,0,0,28,173,1,0,0,0,30,176,1,0,0,0,32,179,1,0,
        0,0,34,181,1,0,0,0,36,184,1,0,0,0,38,189,1,0,0,0,40,191,1,0,0,0,
        42,201,1,0,0,0,44,203,1,0,0,0,46,209,1,0,0,0,48,211,1,0,0,0,50,214,
        1,0,0,0,52,218,1,0,0,0,54,225,1,0,0,0,56,231,1,0,0,0,58,233,1,0,
        0,0,60,236,1,0,0,0,62,240,1,0,0,0,64,242,1,0,0,0,66,247,1,0,0,0,
        68,250,1,0,0,0,70,252,1,0,0,0,72,255,1,0,0,0,74,258,1,0,0,0,76,262,
        1,0,0,0,78,264,1,0,0,0,80,267,1,0,0,0,82,269,1,0,0,0,84,271,1,0,
        0,0,86,273,1,0,0,0,88,277,1,0,0,0,90,280,1,0,0,0,92,283,1,0,0,0,
        94,288,1,0,0,0,96,292,1,0,0,0,98,296,1,0,0,0,100,300,1,0,0,0,102,
        304,1,0,0,0,104,306,1,0,0,0,106,309,1,0,0,0,108,312,1,0,0,0,110,
        315,1,0,0,0,112,318,1,0,0,0,114,322,1,0,0,0,116,325,1,0,0,0,118,
        327,1,0,0,0,120,122,3,108,54,0,121,120,1,0,0,0,121,122,1,0,0,0,122,
        123,1,0,0,0,123,124,3,92,46,0,124,125,3,4,2,0,125,1,1,0,0,0,126,
        127,5,10,0,0,127,128,3,98,49,0,128,3,1,0,0,0,129,134,3,44,22,0,130,
        134,3,50,25,0,131,134,3,64,32,0,132,134,3,6,3,0,133,129,1,0,0,0,
        133,130,1,0,0,0,133,131,1,0,0,0,133,132,1,0,0,0,134,5,1,0,0,0,135,
        136,3,104,52,0,136,137,3,92,46,0,137,138,3,8,4,0,138,7,1,0,0,0,139,
        141,3,10,5,0,140,139,1,0,0,0,140,141,1,0,0,0,141,9,1,0,0,0,142,143,
        5,4,0,0,143,144,3,88,44,0,144,145,3,88,44,0,145,146,3,32,16,0,146,
        11,1,0,0,0,147,148,5,4,0,0,148,149,3,14,7,0,149,13,1,0,0,0,150,153,
        3,16,8,0,151,153,3,40,20,0,152,150,1,0,0,0,152,151,1,0,0,0,153,15,
        1,0,0,0,154,155,3,90,45,0,155,156,3,40,20,0,156,17,1,0,0,0,157,159,
        5,15,0,0,158,157,1,0,0,0,158,159,1,0,0,0,159,19,1,0,0,0,160,162,
        5,8,0,0,161,160,1,0,0,0,161,162,1,0,0,0,162,21,1,0,0,0,163,165,5,
        9,0,0,164,163,1,0,0,0,164,165,1,0,0,0,165,23,1,0,0,0,166,168,5,13,
        0,0,167,166,1,0,0,0,167,168,1,0,0,0,168,25,1,0,0,0,169,171,5,7,0,
        0,170,169,1,0,0,0,170,171,1,0,0,0,171,27,1,0,0,0,172,174,3,2,1,0,
        173,172,1,0,0,0,173,174,1,0,0,0,174,29,1,0,0,0,175,177,3,106,53,
        0,176,175,1,0,0,0,176,177,1,0,0,0,177,31,1,0,0,0,178,180,3,84,42,
        0,179,178,1,0,0,0,179,180,1,0,0,0,180,33,1,0,0,0,181,182,3,32,16,
        0,182,183,3,18,9,0,183,35,1,0,0,0,184,185,3,18,9,0,185,186,3,32,
        16,0,186,37,1,0,0,0,187,190,3,34,17,0,188,190,3,36,18,0,189,187,
        1,0,0,0,189,188,1,0,0,0,190,39,1,0,0,0,191,192,3,72,36,0,192,193,
        3,38,19,0,193,194,3,20,10,0,194,195,3,22,11,0,195,196,3,24,12,0,
        196,197,3,26,13,0,197,198,3,28,14,0,198,199,3,30,15,0,199,41,1,0,
        0,0,200,202,3,78,39,0,201,200,1,0,0,0,201,202,1,0,0,0,202,43,1,0,
        0,0,203,204,3,48,24,0,204,205,3,42,21,0,205,206,3,92,46,0,206,207,
        3,12,6,0,207,45,1,0,0,0,208,210,3,76,38,0,209,208,1,0,0,0,209,210,
        1,0,0,0,210,47,1,0,0,0,211,212,5,18,0,0,212,213,3,46,23,0,213,49,
        1,0,0,0,214,215,3,110,55,0,215,216,3,88,44,0,216,217,3,12,6,0,217,
        51,1,0,0,0,218,219,3,80,40,0,219,220,3,114,57,0,220,221,3,112,56,
        0,221,222,3,116,58,0,222,223,3,74,37,0,223,224,3,80,40,0,224,53,
        1,0,0,0,225,226,5,4,0,0,226,227,3,94,47,0,227,228,3,82,41,0,228,
        55,1,0,0,0,229,232,3,58,29,0,230,232,3,60,30,0,231,229,1,0,0,0,231,
        230,1,0,0,0,232,57,1,0,0,0,233,234,3,102,51,0,234,235,3,88,44,0,
        235,59,1,0,0,0,236,237,3,92,46,0,237,238,3,62,31,0,238,61,1,0,0,
        0,239,241,3,66,33,0,240,239,1,0,0,0,240,241,1,0,0,0,241,63,1,0,0,
        0,242,243,3,52,26,0,243,244,3,56,28,0,244,65,1,0,0,0,245,248,3,70,
        35,0,246,248,3,54,27,0,247,245,1,0,0,0,247,246,1,0,0,0,248,67,1,
        0,0,0,249,251,3,54,27,0,250,249,1,0,0,0,250,251,1,0,0,0,251,69,1,
        0,0,0,252,253,3,100,50,0,253,254,3,68,34,0,254,71,1,0,0,0,255,256,
        7,0,0,0,256,73,1,0,0,0,257,259,5,18,0,0,258,257,1,0,0,0,258,259,
        1,0,0,0,259,75,1,0,0,0,260,263,5,19,0,0,261,263,5,11,0,0,262,260,
        1,0,0,0,262,261,1,0,0,0,263,77,1,0,0,0,264,265,7,1,0,0,265,79,1,
        0,0,0,266,268,5,7,0,0,267,266,1,0,0,0,267,268,1,0,0,0,268,81,1,0,
        0,0,269,270,7,2,0,0,270,83,1,0,0,0,271,272,7,3,0,0,272,85,1,0,0,
        0,273,275,3,72,36,0,274,276,3,72,36,0,275,274,1,0,0,0,275,276,1,
        0,0,0,276,87,1,0,0,0,277,278,3,72,36,0,278,279,3,72,36,0,279,89,
        1,0,0,0,280,281,3,88,44,0,281,282,3,72,36,0,282,91,1,0,0,0,283,285,
        3,88,44,0,284,286,3,72,36,0,285,284,1,0,0,0,285,286,1,0,0,0,286,
        93,1,0,0,0,287,289,3,72,36,0,288,287,1,0,0,0,289,290,1,0,0,0,290,
        288,1,0,0,0,290,291,1,0,0,0,291,95,1,0,0,0,292,294,3,118,59,0,293,
        295,3,94,47,0,294,293,1,0,0,0,294,295,1,0,0,0,295,97,1,0,0,0,296,
        298,3,94,47,0,297,299,3,96,48,0,298,297,1,0,0,0,298,299,1,0,0,0,
        299,99,1,0,0,0,300,301,5,4,0,0,301,302,5,12,0,0,302,303,5,8,0,0,
        303,101,1,0,0,0,304,305,7,3,0,0,305,103,1,0,0,0,306,307,5,2,0,0,
        307,308,5,16,0,0,308,105,1,0,0,0,309,310,5,4,0,0,310,311,5,11,0,
        0,311,107,1,0,0,0,312,313,5,9,0,0,313,314,5,14,0,0,314,109,1,0,0,
        0,315,316,5,16,0,0,316,317,5,15,0,0,317,111,1,0,0,0,318,319,5,6,
        0,0,319,320,5,14,0,0,320,113,1,0,0,0,321,323,5,17,0,0,322,321,1,
        0,0,0,322,323,1,0,0,0,323,115,1,0,0,0,324,326,5,21,0,0,325,324,1,
        0,0,0,325,326,1,0,0,0,326,117,1,0,0,0,327,328,5,1,0,0,328,119,1,
        0,0,0,29,121,133,140,152,158,161,164,167,170,173,176,179,189,201,
        209,231,240,247,250,258,262,267,275,285,290,294,298,322,325
    ]

class fulling_motor_nameParser ( Parser ):

    grammarFileName = "grammar.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.'", "'3'", "<INVALID>", "<INVALID>", 
                     "'A'", "'B'", "'C'", "'E'", "'F'", "'G'", "'H'", "'I'", 
                     "'K'", "'L'", "'M'", "'P'", "'R'", "'S'", "'T'", "'V'", 
                     "'W'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "Three", "RestOfDigits", 
                      "Dash", "A", "B", "C", "E", "F", "G", "H", "I", "K", 
                      "L", "M", "P", "R", "S", "T", "V", "W" ]

    RULE_main = 0
    RULE_gearbox_specifier = 1
    RULE_type_specific = 2
    RULE_three_phase_t = 3
    RULE_three_phase_suffix_opt_our = 4
    RULE_three_phase_suffix_t = 5
    RULE_stepper_suffix_t = 6
    RULE_suffix_with_or_without_tail = 7
    RULE_suffix_with_current = 8
    RULE_double_step_rate_marker = 9
    RULE_encoder_presence_marker = 10
    RULE_unknown_marker_F = 11
    RULE_keyway_marker = 12
    RULE_screwed_shaft_marker = 13
    RULE_gearbox_specifier_opt_our = 14
    RULE_hollow_specifier_opt_our = 15
    RULE_shafts_count_marker_opt_our = 16
    RULE_shafts_count_and_step_rate_any_order_1_t = 17
    RULE_shafts_count_and_step_rate_any_order_2_t = 18
    RULE_shafts_count_and_step_rate_any_order_t = 19
    RULE_stepper_suffix_tail = 20
    RULE_stepper_modifiers_opt_our = 21
    RULE_stepper_t = 22
    RULE_stepper_series_opt_our = 23
    RULE_stepper_marker = 24
    RULE_permanent_t = 25
    RULE_brushless_marker = 26
    RULE_execution_configuration_t = 27
    RULE_brushless_modifier_variants = 28
    RULE_brushless_modifier_poles_torque = 29
    RULE_brushless_modifier_length_electronics_electrics = 30
    RULE_brushless_tail_opt_our = 31
    RULE_brushless_t = 32
    RULE_brushless_tail = 33
    RULE_execution_configuration_opt_our = 34
    RULE_brushless_electronic_tail = 35
    RULE_digit = 36
    RULE_square_marker = 37
    RULE_stepper_series = 38
    RULE_stepper_modifiers_t = 39
    RULE_price_performance_or_unknown_C_marker = 40
    RULE_electrical_unit = 41
    RULE_shafts_count_marker = 42
    RULE_one_or_two_digit_number = 43
    RULE_two_digit_number = 44
    RULE_three_digit_number = 45
    RULE_two_or_three_digit_number = 46
    RULE_any_integer = 47
    RULE_fractional_part = 48
    RULE_float_number = 49
    RULE_integrated_electronic_marker = 50
    RULE_brushless_modifier_poles_torque_letter = 51
    RULE_three_phase_marker = 52
    RULE_hollow_specifier = 53
    RULE_fl = 54
    RULE_permanent_marker = 55
    RULE_brushless_marker_base = 56
    RULE_rounded_marker = 57
    RULE_brushless_flat_marker = 58
    RULE_dot = 59

    ruleNames =  [ "main", "gearbox_specifier", "type_specific", "three_phase_t", 
                   "three_phase_suffix_opt_our", "three_phase_suffix_t", 
                   "stepper_suffix_t", "suffix_with_or_without_tail", "suffix_with_current", 
                   "double_step_rate_marker", "encoder_presence_marker", 
                   "unknown_marker_F", "keyway_marker", "screwed_shaft_marker", 
                   "gearbox_specifier_opt_our", "hollow_specifier_opt_our", 
                   "shafts_count_marker_opt_our", "shafts_count_and_step_rate_any_order_1_t", 
                   "shafts_count_and_step_rate_any_order_2_t", "shafts_count_and_step_rate_any_order_t", 
                   "stepper_suffix_tail", "stepper_modifiers_opt_our", "stepper_t", 
                   "stepper_series_opt_our", "stepper_marker", "permanent_t", 
                   "brushless_marker", "execution_configuration_t", "brushless_modifier_variants", 
                   "brushless_modifier_poles_torque", "brushless_modifier_length_electronics_electrics", 
                   "brushless_tail_opt_our", "brushless_t", "brushless_tail", 
                   "execution_configuration_opt_our", "brushless_electronic_tail", 
                   "digit", "square_marker", "stepper_series", "stepper_modifiers_t", 
                   "price_performance_or_unknown_C_marker", "electrical_unit", 
                   "shafts_count_marker", "one_or_two_digit_number", "two_digit_number", 
                   "three_digit_number", "two_or_three_digit_number", "any_integer", 
                   "fractional_part", "float_number", "integrated_electronic_marker", 
                   "brushless_modifier_poles_torque_letter", "three_phase_marker", 
                   "hollow_specifier", "fl", "permanent_marker", "brushless_marker_base", 
                   "rounded_marker", "brushless_flat_marker", "dot" ]

    EOF = Token.EOF
    T__0=1
    Three=2
    RestOfDigits=3
    Dash=4
    A=5
    B=6
    C=7
    E=8
    F=9
    G=10
    H=11
    I=12
    K=13
    L=14
    M=15
    P=16
    R=17
    S=18
    T=19
    V=20
    W=21

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class MainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.size = None # Two_or_three_digit_numberContext
            self.typed = None # Type_specificContext

        def two_or_three_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_or_three_digit_numberContext,0)


        def type_specific(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Type_specificContext,0)


        def fl(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.FlContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_main

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMain" ):
                listener.enterMain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMain" ):
                listener.exitMain(self)




    def main(self):

        localctx = fulling_motor_nameParser.MainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_main)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 120
                self.fl()


            self.state = 123
            localctx.size = self.two_or_three_digit_number()
            self.state = 124
            localctx.typed = self.type_specific()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Gearbox_specifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ratio = None # Float_numberContext

        def G(self):
            return self.getToken(fulling_motor_nameParser.G, 0)

        def float_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Float_numberContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_gearbox_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGearbox_specifier" ):
                listener.enterGearbox_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGearbox_specifier" ):
                listener.exitGearbox_specifier(self)




    def gearbox_specifier(self):

        localctx = fulling_motor_nameParser.Gearbox_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_gearbox_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.match(fulling_motor_nameParser.G)
            self.state = 127
            localctx.ratio = self.float_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_specificContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.stepper = None # Stepper_tContext
            self.permanent = None # Permanent_tContext
            self.brushless = None # Brushless_tContext
            self.three_phase = None # Three_phase_tContext

        def stepper_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_tContext,0)


        def permanent_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Permanent_tContext,0)


        def brushless_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_tContext,0)


        def three_phase_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Three_phase_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_type_specific

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_specific" ):
                listener.enterType_specific(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_specific" ):
                listener.exitType_specific(self)




    def type_specific(self):

        localctx = fulling_motor_nameParser.Type_specificContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_type_specific)
        try:
            self.state = 133
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [18]:
                self.enterOuterAlt(localctx, 1)
                self.state = 129
                localctx.stepper = self.stepper_t()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 130
                localctx.permanent = self.permanent_t()
                pass
            elif token in [6, 7, 17]:
                self.enterOuterAlt(localctx, 3)
                self.state = 131
                localctx.brushless = self.brushless_t()
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 4)
                self.state = 132
                localctx.three_phase = self.three_phase_t()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Three_phase_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_marker = None # Three_phase_markerContext
            self.motor_body_length = None # Two_or_three_digit_numberContext
            self.suffix = None # Three_phase_suffix_opt_ourContext

        def three_phase_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Three_phase_markerContext,0)


        def two_or_three_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_or_three_digit_numberContext,0)


        def three_phase_suffix_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Three_phase_suffix_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_three_phase_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThree_phase_t" ):
                listener.enterThree_phase_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThree_phase_t" ):
                listener.exitThree_phase_t(self)




    def three_phase_t(self):

        localctx = fulling_motor_nameParser.Three_phase_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_three_phase_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            localctx.type_marker = self.three_phase_marker()
            self.state = 136
            localctx.motor_body_length = self.two_or_three_digit_number()
            self.state = 137
            localctx.suffix = self.three_phase_suffix_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Three_phase_suffix_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def three_phase_suffix_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Three_phase_suffix_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_three_phase_suffix_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThree_phase_suffix_opt_our" ):
                listener.enterThree_phase_suffix_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThree_phase_suffix_opt_our" ):
                listener.exitThree_phase_suffix_opt_our(self)




    def three_phase_suffix_opt_our(self):

        localctx = fulling_motor_nameParser.Three_phase_suffix_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_three_phase_suffix_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 139
                self.three_phase_suffix_t()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Three_phase_suffix_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.current_per_phase_over_ten = None # Two_digit_numberContext
            self.leads = None # Two_digit_numberContext
            self.shafts_count = None # Shafts_count_marker_opt_ourContext

        def Dash(self):
            return self.getToken(fulling_motor_nameParser.Dash, 0)

        def two_digit_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(fulling_motor_nameParser.Two_digit_numberContext)
            else:
                return self.getTypedRuleContext(fulling_motor_nameParser.Two_digit_numberContext,i)


        def shafts_count_marker_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_marker_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_three_phase_suffix_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThree_phase_suffix_t" ):
                listener.enterThree_phase_suffix_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThree_phase_suffix_t" ):
                listener.exitThree_phase_suffix_t(self)




    def three_phase_suffix_t(self):

        localctx = fulling_motor_nameParser.Three_phase_suffix_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_three_phase_suffix_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(fulling_motor_nameParser.Dash)
            self.state = 143
            localctx.current_per_phase_over_ten = self.two_digit_number()
            self.state = 144
            localctx.leads = self.two_digit_number()
            self.state = 145
            localctx.shafts_count = self.shafts_count_marker_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_suffix_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.suffix_body = None # Suffix_with_or_without_tailContext

        def Dash(self):
            return self.getToken(fulling_motor_nameParser.Dash, 0)

        def suffix_with_or_without_tail(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Suffix_with_or_without_tailContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_suffix_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_suffix_t" ):
                listener.enterStepper_suffix_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_suffix_t" ):
                listener.exitStepper_suffix_t(self)




    def stepper_suffix_t(self):

        localctx = fulling_motor_nameParser.Stepper_suffix_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_stepper_suffix_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            self.match(fulling_motor_nameParser.Dash)
            self.state = 148
            localctx.suffix_body = self.suffix_with_or_without_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Suffix_with_or_without_tailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.with_current = None # Suffix_with_currentContext
            self.without_current = None # Stepper_suffix_tailContext

        def suffix_with_current(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Suffix_with_currentContext,0)


        def stepper_suffix_tail(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_suffix_tailContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_suffix_with_or_without_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuffix_with_or_without_tail" ):
                listener.enterSuffix_with_or_without_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuffix_with_or_without_tail" ):
                listener.exitSuffix_with_or_without_tail(self)




    def suffix_with_or_without_tail(self):

        localctx = fulling_motor_nameParser.Suffix_with_or_without_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_suffix_with_or_without_tail)
        try:
            self.state = 152
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 150
                localctx.with_current = self.suffix_with_current()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 151
                localctx.without_current = self.stepper_suffix_tail()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Suffix_with_currentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.current = None # Three_digit_numberContext
            self.tail = None # Stepper_suffix_tailContext

        def three_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Three_digit_numberContext,0)


        def stepper_suffix_tail(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_suffix_tailContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_suffix_with_current

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuffix_with_current" ):
                listener.enterSuffix_with_current(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuffix_with_current" ):
                listener.exitSuffix_with_current(self)




    def suffix_with_current(self):

        localctx = fulling_motor_nameParser.Suffix_with_currentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_suffix_with_current)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            localctx.current = self.three_digit_number()
            self.state = 155
            localctx.tail = self.stepper_suffix_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Double_step_rate_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def M(self):
            return self.getToken(fulling_motor_nameParser.M, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_double_step_rate_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDouble_step_rate_marker" ):
                listener.enterDouble_step_rate_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDouble_step_rate_marker" ):
                listener.exitDouble_step_rate_marker(self)




    def double_step_rate_marker(self):

        localctx = fulling_motor_nameParser.Double_step_rate_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_double_step_rate_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 157
                self.match(fulling_motor_nameParser.M)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Encoder_presence_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def E(self):
            return self.getToken(fulling_motor_nameParser.E, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_encoder_presence_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEncoder_presence_marker" ):
                listener.enterEncoder_presence_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEncoder_presence_marker" ):
                listener.exitEncoder_presence_marker(self)




    def encoder_presence_marker(self):

        localctx = fulling_motor_nameParser.Encoder_presence_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_encoder_presence_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 160
                self.match(fulling_motor_nameParser.E)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unknown_marker_FContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def F(self):
            return self.getToken(fulling_motor_nameParser.F, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_unknown_marker_F

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnknown_marker_F" ):
                listener.enterUnknown_marker_F(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnknown_marker_F" ):
                listener.exitUnknown_marker_F(self)




    def unknown_marker_F(self):

        localctx = fulling_motor_nameParser.Unknown_marker_FContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_unknown_marker_F)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 163
                self.match(fulling_motor_nameParser.F)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Keyway_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K(self):
            return self.getToken(fulling_motor_nameParser.K, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_keyway_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyway_marker" ):
                listener.enterKeyway_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyway_marker" ):
                listener.exitKeyway_marker(self)




    def keyway_marker(self):

        localctx = fulling_motor_nameParser.Keyway_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_keyway_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 166
                self.match(fulling_motor_nameParser.K)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Screwed_shaft_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def C(self):
            return self.getToken(fulling_motor_nameParser.C, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_screwed_shaft_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScrewed_shaft_marker" ):
                listener.enterScrewed_shaft_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScrewed_shaft_marker" ):
                listener.exitScrewed_shaft_marker(self)




    def screwed_shaft_marker(self):

        localctx = fulling_motor_nameParser.Screwed_shaft_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_screwed_shaft_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 169
                self.match(fulling_motor_nameParser.C)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Gearbox_specifier_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gearbox_specifier(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Gearbox_specifierContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_gearbox_specifier_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGearbox_specifier_opt_our" ):
                listener.enterGearbox_specifier_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGearbox_specifier_opt_our" ):
                listener.exitGearbox_specifier_opt_our(self)




    def gearbox_specifier_opt_our(self):

        localctx = fulling_motor_nameParser.Gearbox_specifier_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_gearbox_specifier_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 172
                self.gearbox_specifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hollow_specifier_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hollow_specifier(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Hollow_specifierContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_hollow_specifier_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHollow_specifier_opt_our" ):
                listener.enterHollow_specifier_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHollow_specifier_opt_our" ):
                listener.exitHollow_specifier_opt_our(self)




    def hollow_specifier_opt_our(self):

        localctx = fulling_motor_nameParser.Hollow_specifier_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_hollow_specifier_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 175
                self.hollow_specifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shafts_count_marker_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shafts_count_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_markerContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_shafts_count_marker_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShafts_count_marker_opt_our" ):
                listener.enterShafts_count_marker_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShafts_count_marker_opt_our" ):
                listener.exitShafts_count_marker_opt_our(self)




    def shafts_count_marker_opt_our(self):

        localctx = fulling_motor_nameParser.Shafts_count_marker_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_shafts_count_marker_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5 or _la==6:
                self.state = 178
                self.shafts_count_marker()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shafts_count_and_step_rate_any_order_1_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.shafts_count = None # Shafts_count_marker_opt_ourContext
            self.step_rate = None # Double_step_rate_markerContext

        def shafts_count_marker_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_marker_opt_ourContext,0)


        def double_step_rate_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Double_step_rate_markerContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_shafts_count_and_step_rate_any_order_1_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShafts_count_and_step_rate_any_order_1_t" ):
                listener.enterShafts_count_and_step_rate_any_order_1_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShafts_count_and_step_rate_any_order_1_t" ):
                listener.exitShafts_count_and_step_rate_any_order_1_t(self)




    def shafts_count_and_step_rate_any_order_1_t(self):

        localctx = fulling_motor_nameParser.Shafts_count_and_step_rate_any_order_1_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_shafts_count_and_step_rate_any_order_1_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            localctx.shafts_count = self.shafts_count_marker_opt_our()
            self.state = 182
            localctx.step_rate = self.double_step_rate_marker()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shafts_count_and_step_rate_any_order_2_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.step_rate = None # Double_step_rate_markerContext
            self.shafts_count = None # Shafts_count_marker_opt_ourContext

        def double_step_rate_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Double_step_rate_markerContext,0)


        def shafts_count_marker_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_marker_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_shafts_count_and_step_rate_any_order_2_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShafts_count_and_step_rate_any_order_2_t" ):
                listener.enterShafts_count_and_step_rate_any_order_2_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShafts_count_and_step_rate_any_order_2_t" ):
                listener.exitShafts_count_and_step_rate_any_order_2_t(self)




    def shafts_count_and_step_rate_any_order_2_t(self):

        localctx = fulling_motor_nameParser.Shafts_count_and_step_rate_any_order_2_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_shafts_count_and_step_rate_any_order_2_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            localctx.step_rate = self.double_step_rate_marker()
            self.state = 185
            localctx.shafts_count = self.shafts_count_marker_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shafts_count_and_step_rate_any_order_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.shafts_count_and_step_rate_any_order_1 = None # Shafts_count_and_step_rate_any_order_1_tContext
            self.shafts_count_and_step_rate_any_order_2 = None # Shafts_count_and_step_rate_any_order_2_tContext

        def shafts_count_and_step_rate_any_order_1_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_and_step_rate_any_order_1_tContext,0)


        def shafts_count_and_step_rate_any_order_2_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_and_step_rate_any_order_2_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_shafts_count_and_step_rate_any_order_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShafts_count_and_step_rate_any_order_t" ):
                listener.enterShafts_count_and_step_rate_any_order_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShafts_count_and_step_rate_any_order_t" ):
                listener.exitShafts_count_and_step_rate_any_order_t(self)




    def shafts_count_and_step_rate_any_order_t(self):

        localctx = fulling_motor_nameParser.Shafts_count_and_step_rate_any_order_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_shafts_count_and_step_rate_any_order_t)
        try:
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 187
                localctx.shafts_count_and_step_rate_any_order_1 = self.shafts_count_and_step_rate_any_order_1_t()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 188
                localctx.shafts_count_and_step_rate_any_order_2 = self.shafts_count_and_step_rate_any_order_2_t()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_suffix_tailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.variant = None # DigitContext
            self.shafts_count_and_step_rate_any_order = None # Shafts_count_and_step_rate_any_order_tContext
            self.encoder = None # Encoder_presence_markerContext
            self.unknown_F = None # Unknown_marker_FContext
            self.key_way = None # Keyway_markerContext
            self.screwed_shaft = None # Screwed_shaft_markerContext
            self.gearbox = None # Gearbox_specifier_opt_ourContext
            self.hollow = None # Hollow_specifier_opt_ourContext

        def digit(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.DigitContext,0)


        def shafts_count_and_step_rate_any_order_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Shafts_count_and_step_rate_any_order_tContext,0)


        def encoder_presence_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Encoder_presence_markerContext,0)


        def unknown_marker_F(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Unknown_marker_FContext,0)


        def keyway_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Keyway_markerContext,0)


        def screwed_shaft_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Screwed_shaft_markerContext,0)


        def gearbox_specifier_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Gearbox_specifier_opt_ourContext,0)


        def hollow_specifier_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Hollow_specifier_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_suffix_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_suffix_tail" ):
                listener.enterStepper_suffix_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_suffix_tail" ):
                listener.exitStepper_suffix_tail(self)




    def stepper_suffix_tail(self):

        localctx = fulling_motor_nameParser.Stepper_suffix_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_stepper_suffix_tail)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            localctx.variant = self.digit()
            self.state = 192
            localctx.shafts_count_and_step_rate_any_order = self.shafts_count_and_step_rate_any_order_t()
            self.state = 193
            localctx.encoder = self.encoder_presence_marker()
            self.state = 194
            localctx.unknown_F = self.unknown_marker_F()
            self.state = 195
            localctx.key_way = self.keyway_marker()
            self.state = 196
            localctx.screwed_shaft = self.screwed_shaft_marker()
            self.state = 197
            localctx.gearbox = self.gearbox_specifier_opt_our()
            self.state = 198
            localctx.hollow = self.hollow_specifier_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_modifiers_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stepper_modifiers_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_modifiers_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_modifiers_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_modifiers_opt_our" ):
                listener.enterStepper_modifiers_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_modifiers_opt_our" ):
                listener.exitStepper_modifiers_opt_our(self)




    def stepper_modifiers_opt_our(self):

        localctx = fulling_motor_nameParser.Stepper_modifiers_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_stepper_modifiers_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7 or _la==11:
                self.state = 200
                self.stepper_modifiers_t()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_marker = None # Stepper_markerContext
            self.stepper_modifiers = None # Stepper_modifiers_opt_ourContext
            self.motor_body_length = None # Two_or_three_digit_numberContext
            self.suffix = None # Stepper_suffix_tContext

        def stepper_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_markerContext,0)


        def stepper_modifiers_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_modifiers_opt_ourContext,0)


        def two_or_three_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_or_three_digit_numberContext,0)


        def stepper_suffix_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_suffix_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_t" ):
                listener.enterStepper_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_t" ):
                listener.exitStepper_t(self)




    def stepper_t(self):

        localctx = fulling_motor_nameParser.Stepper_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_stepper_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            localctx.type_marker = self.stepper_marker()
            self.state = 204
            localctx.stepper_modifiers = self.stepper_modifiers_opt_our()
            self.state = 205
            localctx.motor_body_length = self.two_or_three_digit_number()
            self.state = 206
            localctx.suffix = self.stepper_suffix_t()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_series_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stepper_series(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_seriesContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_series_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_series_opt_our" ):
                listener.enterStepper_series_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_series_opt_our" ):
                listener.exitStepper_series_opt_our(self)




    def stepper_series_opt_our(self):

        localctx = fulling_motor_nameParser.Stepper_series_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_stepper_series_opt_our)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 208
                self.stepper_series()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.series = None # Stepper_series_opt_ourContext

        def S(self):
            return self.getToken(fulling_motor_nameParser.S, 0)

        def stepper_series_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_series_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_marker" ):
                listener.enterStepper_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_marker" ):
                listener.exitStepper_marker(self)




    def stepper_marker(self):

        localctx = fulling_motor_nameParser.Stepper_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_stepper_marker)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(fulling_motor_nameParser.S)
            self.state = 212
            localctx.series = self.stepper_series_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Permanent_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_marker = None # Permanent_markerContext
            self.motor_body_length = None # Two_digit_numberContext
            self.suffix = None # Stepper_suffix_tContext

        def permanent_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Permanent_markerContext,0)


        def two_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_digit_numberContext,0)


        def stepper_suffix_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Stepper_suffix_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_permanent_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPermanent_t" ):
                listener.enterPermanent_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPermanent_t" ):
                listener.exitPermanent_t(self)




    def permanent_t(self):

        localctx = fulling_motor_nameParser.Permanent_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_permanent_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            localctx.type_marker = self.permanent_marker()
            self.state = 215
            localctx.motor_body_length = self.two_digit_number()
            self.state = 216
            localctx.suffix = self.stepper_suffix_t()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.is_price_performance = None # Price_performance_or_unknown_C_markerContext
            self.is_round = None # Rounded_markerContext
            self.is_flat = None # Brushless_flat_markerContext
            self.is_square = None # Square_markerContext
            self.is_unknown_C = None # Price_performance_or_unknown_C_markerContext

        def brushless_marker_base(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_marker_baseContext,0)


        def price_performance_or_unknown_C_marker(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(fulling_motor_nameParser.Price_performance_or_unknown_C_markerContext)
            else:
                return self.getTypedRuleContext(fulling_motor_nameParser.Price_performance_or_unknown_C_markerContext,i)


        def rounded_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Rounded_markerContext,0)


        def brushless_flat_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_flat_markerContext,0)


        def square_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Square_markerContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_marker" ):
                listener.enterBrushless_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_marker" ):
                listener.exitBrushless_marker(self)




    def brushless_marker(self):

        localctx = fulling_motor_nameParser.Brushless_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_brushless_marker)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            localctx.is_price_performance = self.price_performance_or_unknown_C_marker()
            self.state = 219
            localctx.is_round = self.rounded_marker()
            self.state = 220
            self.brushless_marker_base()
            self.state = 221
            localctx.is_flat = self.brushless_flat_marker()
            self.state = 222
            localctx.is_square = self.square_marker()
            self.state = 223
            localctx.is_unknown_C = self.price_performance_or_unknown_C_marker()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Execution_configuration_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.number = None # Any_integerContext
            self.unit = None # Electrical_unitContext

        def Dash(self):
            return self.getToken(fulling_motor_nameParser.Dash, 0)

        def any_integer(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Any_integerContext,0)


        def electrical_unit(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Electrical_unitContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_execution_configuration_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecution_configuration_t" ):
                listener.enterExecution_configuration_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecution_configuration_t" ):
                listener.exitExecution_configuration_t(self)




    def execution_configuration_t(self):

        localctx = fulling_motor_nameParser.Execution_configuration_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_execution_configuration_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.match(fulling_motor_nameParser.Dash)
            self.state = 226
            localctx.number = self.any_integer()
            self.state = 227
            localctx.unit = self.electrical_unit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_modifier_variantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.poles_torque = None # Brushless_modifier_poles_torqueContext
            self.length_electronics_electrics = None # Brushless_modifier_length_electronics_electricsContext

        def brushless_modifier_poles_torque(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_modifier_poles_torqueContext,0)


        def brushless_modifier_length_electronics_electrics(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_modifier_length_electronics_electricsContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_modifier_variants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_modifier_variants" ):
                listener.enterBrushless_modifier_variants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_modifier_variants" ):
                listener.exitBrushless_modifier_variants(self)




    def brushless_modifier_variants(self):

        localctx = fulling_motor_nameParser.Brushless_modifier_variantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_brushless_modifier_variants)
        try:
            self.state = 231
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 229
                localctx.poles_torque = self.brushless_modifier_poles_torque()
                pass
            elif token in [2, 3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 230
                localctx.length_electronics_electrics = self.brushless_modifier_length_electronics_electrics()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_modifier_poles_torqueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.poles_or_other = None # Brushless_modifier_poles_torque_letterContext
            self.variant = None # Two_digit_numberContext

        def brushless_modifier_poles_torque_letter(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_modifier_poles_torque_letterContext,0)


        def two_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_digit_numberContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_modifier_poles_torque

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_modifier_poles_torque" ):
                listener.enterBrushless_modifier_poles_torque(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_modifier_poles_torque" ):
                listener.exitBrushless_modifier_poles_torque(self)




    def brushless_modifier_poles_torque(self):

        localctx = fulling_motor_nameParser.Brushless_modifier_poles_torqueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_brushless_modifier_poles_torque)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            localctx.poles_or_other = self.brushless_modifier_poles_torque_letter()
            self.state = 234
            localctx.variant = self.two_digit_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_modifier_length_electronics_electricsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.motor_body_length = None # Two_or_three_digit_numberContext
            self.tail = None # Brushless_tail_opt_ourContext

        def two_or_three_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_or_three_digit_numberContext,0)


        def brushless_tail_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_tail_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_modifier_length_electronics_electrics

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_modifier_length_electronics_electrics" ):
                listener.enterBrushless_modifier_length_electronics_electrics(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_modifier_length_electronics_electrics" ):
                listener.exitBrushless_modifier_length_electronics_electrics(self)




    def brushless_modifier_length_electronics_electrics(self):

        localctx = fulling_motor_nameParser.Brushless_modifier_length_electronics_electricsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_brushless_modifier_length_electronics_electrics)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            localctx.motor_body_length = self.two_or_three_digit_number()
            self.state = 237
            localctx.tail = self.brushless_tail_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_tail_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def brushless_tail(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_tailContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_tail_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_tail_opt_our" ):
                listener.enterBrushless_tail_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_tail_opt_our" ):
                listener.exitBrushless_tail_opt_our(self)




    def brushless_tail_opt_our(self):

        localctx = fulling_motor_nameParser.Brushless_tail_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_brushless_tail_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 239
                self.brushless_tail()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_marker = None # Brushless_markerContext
            self.modifier = None # Brushless_modifier_variantsContext

        def brushless_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_markerContext,0)


        def brushless_modifier_variants(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_modifier_variantsContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_t" ):
                listener.enterBrushless_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_t" ):
                listener.exitBrushless_t(self)




    def brushless_t(self):

        localctx = fulling_motor_nameParser.Brushless_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_brushless_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            localctx.type_marker = self.brushless_marker()
            self.state = 243
            localctx.modifier = self.brushless_modifier_variants()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_tailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.electronic = None # Brushless_electronic_tailContext
            self.no_electronic = None # Execution_configuration_tContext

        def brushless_electronic_tail(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Brushless_electronic_tailContext,0)


        def execution_configuration_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Execution_configuration_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_tail" ):
                listener.enterBrushless_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_tail" ):
                listener.exitBrushless_tail(self)




    def brushless_tail(self):

        localctx = fulling_motor_nameParser.Brushless_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_brushless_tail)
        try:
            self.state = 247
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 245
                localctx.electronic = self.brushless_electronic_tail()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 246
                localctx.no_electronic = self.execution_configuration_t()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Execution_configuration_opt_ourContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def execution_configuration_t(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Execution_configuration_tContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_execution_configuration_opt_our

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecution_configuration_opt_our" ):
                listener.enterExecution_configuration_opt_our(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecution_configuration_opt_our" ):
                listener.exitExecution_configuration_opt_our(self)




    def execution_configuration_opt_our(self):

        localctx = fulling_motor_nameParser.Execution_configuration_opt_ourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_execution_configuration_opt_our)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 249
                self.execution_configuration_t()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_electronic_tailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.has_electronics = None # Integrated_electronic_markerContext
            self.cfg = None # Execution_configuration_opt_ourContext

        def integrated_electronic_marker(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Integrated_electronic_markerContext,0)


        def execution_configuration_opt_our(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Execution_configuration_opt_ourContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_electronic_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_electronic_tail" ):
                listener.enterBrushless_electronic_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_electronic_tail" ):
                listener.exitBrushless_electronic_tail(self)




    def brushless_electronic_tail(self):

        localctx = fulling_motor_nameParser.Brushless_electronic_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_brushless_electronic_tail)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            localctx.has_electronics = self.integrated_electronic_marker()
            self.state = 253
            localctx.cfg = self.execution_configuration_opt_our()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DigitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RestOfDigits(self):
            return self.getToken(fulling_motor_nameParser.RestOfDigits, 0)

        def Three(self):
            return self.getToken(fulling_motor_nameParser.Three, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_digit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDigit" ):
                listener.enterDigit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDigit" ):
                listener.exitDigit(self)




    def digit(self):

        localctx = fulling_motor_nameParser.DigitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_digit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            _la = self._input.LA(1)
            if not(_la==2 or _la==3):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Square_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(fulling_motor_nameParser.S, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_square_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSquare_marker" ):
                listener.enterSquare_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSquare_marker" ):
                listener.exitSquare_marker(self)




    def square_marker(self):

        localctx = fulling_motor_nameParser.Square_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_square_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 257
                self.match(fulling_motor_nameParser.S)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_seriesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.standard = None # Token
            self.hybrid = None # Token

        def T(self):
            return self.getToken(fulling_motor_nameParser.T, 0)

        def H(self):
            return self.getToken(fulling_motor_nameParser.H, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_series

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_series" ):
                listener.enterStepper_series(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_series" ):
                listener.exitStepper_series(self)




    def stepper_series(self):

        localctx = fulling_motor_nameParser.Stepper_seriesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_stepper_series)
        try:
            self.state = 262
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.enterOuterAlt(localctx, 1)
                self.state = 260
                localctx.standard = self.match(fulling_motor_nameParser.T)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 261
                localctx.hybrid = self.match(fulling_motor_nameParser.H)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stepper_modifiers_tContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.stepper_modifiers = None # Token

        def H(self):
            return self.getToken(fulling_motor_nameParser.H, 0)

        def C(self):
            return self.getToken(fulling_motor_nameParser.C, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_stepper_modifiers_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStepper_modifiers_t" ):
                listener.enterStepper_modifiers_t(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStepper_modifiers_t" ):
                listener.exitStepper_modifiers_t(self)




    def stepper_modifiers_t(self):

        localctx = fulling_motor_nameParser.Stepper_modifiers_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_stepper_modifiers_t)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            localctx.stepper_modifiers = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==7 or _la==11):
                localctx.stepper_modifiers = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Price_performance_or_unknown_C_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def C(self):
            return self.getToken(fulling_motor_nameParser.C, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_price_performance_or_unknown_C_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrice_performance_or_unknown_C_marker" ):
                listener.enterPrice_performance_or_unknown_C_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrice_performance_or_unknown_C_marker" ):
                listener.exitPrice_performance_or_unknown_C_marker(self)




    def price_performance_or_unknown_C_marker(self):

        localctx = fulling_motor_nameParser.Price_performance_or_unknown_C_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_price_performance_or_unknown_C_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 266
                self.match(fulling_motor_nameParser.C)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Electrical_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def A(self):
            return self.getToken(fulling_motor_nameParser.A, 0)

        def V(self):
            return self.getToken(fulling_motor_nameParser.V, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_electrical_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElectrical_unit" ):
                listener.enterElectrical_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElectrical_unit" ):
                listener.exitElectrical_unit(self)




    def electrical_unit(self):

        localctx = fulling_motor_nameParser.Electrical_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_electrical_unit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            _la = self._input.LA(1)
            if not(_la==5 or _la==20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shafts_count_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def A(self):
            return self.getToken(fulling_motor_nameParser.A, 0)

        def B(self):
            return self.getToken(fulling_motor_nameParser.B, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_shafts_count_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShafts_count_marker" ):
                listener.enterShafts_count_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShafts_count_marker" ):
                listener.exitShafts_count_marker(self)




    def shafts_count_marker(self):

        localctx = fulling_motor_nameParser.Shafts_count_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_shafts_count_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            _la = self._input.LA(1)
            if not(_la==5 or _la==6):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class One_or_two_digit_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(fulling_motor_nameParser.DigitContext)
            else:
                return self.getTypedRuleContext(fulling_motor_nameParser.DigitContext,i)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_one_or_two_digit_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOne_or_two_digit_number" ):
                listener.enterOne_or_two_digit_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOne_or_two_digit_number" ):
                listener.exitOne_or_two_digit_number(self)




    def one_or_two_digit_number(self):

        localctx = fulling_motor_nameParser.One_or_two_digit_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_one_or_two_digit_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.digit()
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2 or _la==3:
                self.state = 274
                self.digit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Two_digit_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(fulling_motor_nameParser.DigitContext)
            else:
                return self.getTypedRuleContext(fulling_motor_nameParser.DigitContext,i)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_two_digit_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwo_digit_number" ):
                listener.enterTwo_digit_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwo_digit_number" ):
                listener.exitTwo_digit_number(self)




    def two_digit_number(self):

        localctx = fulling_motor_nameParser.Two_digit_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_two_digit_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.digit()
            self.state = 278
            self.digit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Three_digit_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def two_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_digit_numberContext,0)


        def digit(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.DigitContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_three_digit_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThree_digit_number" ):
                listener.enterThree_digit_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThree_digit_number" ):
                listener.exitThree_digit_number(self)




    def three_digit_number(self):

        localctx = fulling_motor_nameParser.Three_digit_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_three_digit_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.two_digit_number()
            self.state = 281
            self.digit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Two_or_three_digit_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def two_digit_number(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Two_digit_numberContext,0)


        def digit(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.DigitContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_two_or_three_digit_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwo_or_three_digit_number" ):
                listener.enterTwo_or_three_digit_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwo_or_three_digit_number" ):
                listener.exitTwo_or_three_digit_number(self)




    def two_or_three_digit_number(self):

        localctx = fulling_motor_nameParser.Two_or_three_digit_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_two_or_three_digit_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.two_digit_number()
            self.state = 285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 284
                self.digit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_integerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(fulling_motor_nameParser.DigitContext)
            else:
                return self.getTypedRuleContext(fulling_motor_nameParser.DigitContext,i)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_any_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAny_integer" ):
                listener.enterAny_integer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAny_integer" ):
                listener.exitAny_integer(self)




    def any_integer(self):

        localctx = fulling_motor_nameParser.Any_integerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_any_integer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 287
                self.digit()
                self.state = 290 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==2 or _la==3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fractional_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dot(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.DotContext,0)


        def any_integer(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Any_integerContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_fractional_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFractional_part" ):
                listener.enterFractional_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFractional_part" ):
                listener.exitFractional_part(self)




    def fractional_part(self):

        localctx = fulling_motor_nameParser.Fractional_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_fractional_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.dot()
            self.state = 294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2 or _la==3:
                self.state = 293
                self.any_integer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Float_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_integer(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Any_integerContext,0)


        def fractional_part(self):
            return self.getTypedRuleContext(fulling_motor_nameParser.Fractional_partContext,0)


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_float_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloat_number" ):
                listener.enterFloat_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloat_number" ):
                listener.exitFloat_number(self)




    def float_number(self):

        localctx = fulling_motor_nameParser.Float_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_float_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.any_integer()
            self.state = 298
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 297
                self.fractional_part()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integrated_electronic_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dash(self):
            return self.getToken(fulling_motor_nameParser.Dash, 0)

        def I(self):
            return self.getToken(fulling_motor_nameParser.I, 0)

        def E(self):
            return self.getToken(fulling_motor_nameParser.E, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_integrated_electronic_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegrated_electronic_marker" ):
                listener.enterIntegrated_electronic_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegrated_electronic_marker" ):
                listener.exitIntegrated_electronic_marker(self)




    def integrated_electronic_marker(self):

        localctx = fulling_motor_nameParser.Integrated_electronic_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_integrated_electronic_marker)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(fulling_motor_nameParser.Dash)
            self.state = 301
            self.match(fulling_motor_nameParser.I)
            self.state = 302
            self.match(fulling_motor_nameParser.E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_modifier_poles_torque_letterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def A(self):
            return self.getToken(fulling_motor_nameParser.A, 0)

        def B(self):
            return self.getToken(fulling_motor_nameParser.B, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_modifier_poles_torque_letter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_modifier_poles_torque_letter" ):
                listener.enterBrushless_modifier_poles_torque_letter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_modifier_poles_torque_letter" ):
                listener.exitBrushless_modifier_poles_torque_letter(self)




    def brushless_modifier_poles_torque_letter(self):

        localctx = fulling_motor_nameParser.Brushless_modifier_poles_torque_letterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_brushless_modifier_poles_torque_letter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            _la = self._input.LA(1)
            if not(_la==5 or _la==6):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Three_phase_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Three(self):
            return self.getToken(fulling_motor_nameParser.Three, 0)

        def P(self):
            return self.getToken(fulling_motor_nameParser.P, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_three_phase_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThree_phase_marker" ):
                listener.enterThree_phase_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThree_phase_marker" ):
                listener.exitThree_phase_marker(self)




    def three_phase_marker(self):

        localctx = fulling_motor_nameParser.Three_phase_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_three_phase_marker)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(fulling_motor_nameParser.Three)
            self.state = 307
            self.match(fulling_motor_nameParser.P)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hollow_specifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dash(self):
            return self.getToken(fulling_motor_nameParser.Dash, 0)

        def H(self):
            return self.getToken(fulling_motor_nameParser.H, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_hollow_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHollow_specifier" ):
                listener.enterHollow_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHollow_specifier" ):
                listener.exitHollow_specifier(self)




    def hollow_specifier(self):

        localctx = fulling_motor_nameParser.Hollow_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_hollow_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.match(fulling_motor_nameParser.Dash)
            self.state = 310
            self.match(fulling_motor_nameParser.H)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def F(self):
            return self.getToken(fulling_motor_nameParser.F, 0)

        def L(self):
            return self.getToken(fulling_motor_nameParser.L, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_fl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFl" ):
                listener.enterFl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFl" ):
                listener.exitFl(self)




    def fl(self):

        localctx = fulling_motor_nameParser.FlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_fl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.match(fulling_motor_nameParser.F)
            self.state = 313
            self.match(fulling_motor_nameParser.L)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Permanent_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def P(self):
            return self.getToken(fulling_motor_nameParser.P, 0)

        def M(self):
            return self.getToken(fulling_motor_nameParser.M, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_permanent_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPermanent_marker" ):
                listener.enterPermanent_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPermanent_marker" ):
                listener.exitPermanent_marker(self)




    def permanent_marker(self):

        localctx = fulling_motor_nameParser.Permanent_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_permanent_marker)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self.match(fulling_motor_nameParser.P)
            self.state = 316
            self.match(fulling_motor_nameParser.M)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_marker_baseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def B(self):
            return self.getToken(fulling_motor_nameParser.B, 0)

        def L(self):
            return self.getToken(fulling_motor_nameParser.L, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_marker_base

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_marker_base" ):
                listener.enterBrushless_marker_base(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_marker_base" ):
                listener.exitBrushless_marker_base(self)




    def brushless_marker_base(self):

        localctx = fulling_motor_nameParser.Brushless_marker_baseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_brushless_marker_base)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(fulling_motor_nameParser.B)
            self.state = 319
            self.match(fulling_motor_nameParser.L)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rounded_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def R(self):
            return self.getToken(fulling_motor_nameParser.R, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_rounded_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRounded_marker" ):
                listener.enterRounded_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRounded_marker" ):
                listener.exitRounded_marker(self)




    def rounded_marker(self):

        localctx = fulling_motor_nameParser.Rounded_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_rounded_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 321
                self.match(fulling_motor_nameParser.R)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Brushless_flat_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def W(self):
            return self.getToken(fulling_motor_nameParser.W, 0)

        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_brushless_flat_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBrushless_flat_marker" ):
                listener.enterBrushless_flat_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBrushless_flat_marker" ):
                listener.exitBrushless_flat_marker(self)




    def brushless_flat_marker(self):

        localctx = fulling_motor_nameParser.Brushless_flat_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_brushless_flat_marker)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 324
                self.match(fulling_motor_nameParser.W)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return fulling_motor_nameParser.RULE_dot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDot" ):
                listener.enterDot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDot" ):
                listener.exitDot(self)




    def dot(self):

        localctx = fulling_motor_nameParser.DotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_dot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.match(fulling_motor_nameParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





